---
description: 
globs: 
alwaysApply: false
---
# Trump Selection Validation - Complete Backend Flow

## Overview
This document details the complete validation flow for the trump selection phase of Sjavs. Every player action must be rigorously validated against the Redis database state before any state changes occur. The Redis database serves as the single source of truth for all game state.

## Game State Architecture

### Redis Data Structure
```
game:{game_id} = {
    status: "waiting" | "dealing" | "bidding" | "trump_declaration" | "playing" | "completed",
    dealer_position: 0-3,
    current_bidder: 0-3,
    players: [
        { user_id: "user1", position: 0, hand: ["AS", "KH", ...], ready: true },
        { user_id: "user2", position: 1, hand: ["QC", "JD", ...], ready: true },
        { user_id: "user3", position: 2, hand: ["10S", "9H", ...], ready: true },
        { user_id: "user4", position: 3, hand: ["7C", "8D", ...], ready: true }
    ],
    bidding: {
        current_highest_length: 0,
        current_highest_bidder: null,
        bid_history: [
            { player_position: 0, bid_length: 5, passed: false },
            { player_position: 1, bid_length: null, passed: true }
        ],
        bidding_complete: false
    },
    trump: {
        suit: null,
        declared_by: null
    },
    created_at: timestamp,
    updated_at: timestamp
}
```

## Trump Selection Phase Validation Flow

### Phase 1: Game Initialization & Dealing

#### 1.1 Start New Game Request
**Endpoint**: `POST /game/start`
**Request**: `{ "game_id": "match-123" }`

**Validation Sequence**:
1. **Match Existence**: Verify `game:{game_id}` exists in Redis
2. **Player Count**: Ensure exactly 4 players in the match
3. **Player Readiness**: All players must be in "ready" state
4. **Game Status**: Game must be in "waiting" status
5. **Player Authentication**: Validate requesting user is in the match

**Success Actions**:
- Set `status = "dealing"`
- Initialize deck (32 cards)
- Deal 8 cards to each player
- Store hands in Redis
- Set `dealer_position` (random for first game, rotate for subsequent)
- Set `current_bidder = (dealer_position + 1) % 4`
- Set `status = "bidding"`
- Broadcast game state to all players

**Failure Cases**:
- Return 404 if game not found
- Return 400 if not enough players or players not ready
- Return 409 if game already in progress
- Return 403 if requesting user not in game

#### 1.2 Deal Validation
**Internal Process** (no direct endpoint)

**Critical Validations**:
1. **Deck Integrity**: Ensure exactly 32 cards (no 2s-6s)
2. **Hand Distribution**: Each player gets exactly 8 cards
3. **No Duplicates**: No card appears in multiple hands
4. **Complete Distribution**: All 32 cards distributed

### Phase 2: Bidding Process

#### 2.1 Place Bid Request
**Endpoint**: `POST /game/bid`
**Request**: `{ "game_id": "match-123", "bid_length": 6, "trump_suit": "clubs" }`

**Pre-Validation Sequence**:
1. **Game Existence**: Verify `game:{game_id}` exists
2. **Game Status**: Must be in "bidding" status
3. **Player Authentication**: Validate user is in this game
4. **Turn Validation**: Must be requesting player's turn to bid
5. **Bidding Status**: Bidding must not be complete

**Turn Validation Logic**:
```rust
fn validate_bidding_turn(game_state: &GameState, user_id: &str) -> Result<(), ValidationError> {
    let player_position = game_state.get_player_position(user_id)?;
    let expected_bidder = game_state.bidding.current_bidder;
    
    if player_position != expected_bidder {
        return Err(ValidationError::NotYourTurn);
    }
    Ok(())
}
```

**Bid Validation Logic**:
```rust
fn validate_bid(game_state: &GameState, player_position: usize, bid_length: u8, trump_suit: Suit) -> Result<(), ValidationError> {
    let player_hand = &game_state.players[player_position].hand;
    
    if bid_length < 5 {
        return Err(ValidationError::BidTooLow);
    }
    
    // Check if player actually has claimed trump count in specified suit
    let actual_trump_count = calculate_trump_count(player_hand, trump_suit);
    if actual_trump_count != bid_length {
        return Err(ValidationError::BidExceedsActualTrumps);
    }
    
    // Check if bid is better than current highest
    let current_highest = game_state.bidding.current_highest_length;
    if bid_length < current_highest {
        return Err(ValidationError::BidNotBetter);
    }
    
    if bid_length == current_highest {
        // Same length only valid if declaring clubs
        if trump_suit != Suit::Clubs {
            return Err(ValidationError::BidNotBetter);
        }
    }
    
    Ok(())
}
```

**Trump Count Calculation**:
```rust
fn calculate_trump_count(hand: &[Card], trump_suit: Suit) -> u8 {
    let permanent_trumps = [
        Card::new(Suit::Clubs, Rank::Queen),
        Card::new(Suit::Spades, Rank::Queen),
        Card::new(Suit::Clubs, Rank::Jack),
        Card::new(Suit::Spades, Rank::Jack),
        Card::new(Suit::Hearts, Rank::Jack),
        Card::new(Suit::Diamonds, Rank::Jack),
    ];
    
    let mut count = 0;
    
    for card in hand {
        // Count permanent trumps
        if permanent_trumps.contains(card) {
            count += 1;
        }
        // Count suit trumps (excluding permanent trumps)
        else if card.suit == trump_suit {
            count += 1;
        }
    }
    
    count
}
```

**Success Actions**:
- Update `bidding.current_highest_length`
- Update `bidding.current_highest_bidder`
- Store `trump.suit` (private to backend, not broadcast until bidding complete)
- Add bid to `bidding.bid_history` (only length visible to other players)
- Advance `current_bidder` to next player
- Broadcast updated bidding state (trump suit hidden)

#### 2.2 Pass Bid Request
**Endpoint**: `POST /game/pass`
**Request**: `{ "game_id": "match-123" }`

**Validation Sequence**:
1. Same pre-validations as bid request
2. **Pass Validity**: Ensure player hasn't already passed in this round

**Success Actions**:
- Add pass to `bidding.bid_history`
- Advance `current_bidder` to next player
- Check if bidding is complete

#### 2.3 Bidding Completion Check
**Internal Logic** (triggered after each bid/pass)

**Completion Conditions**:
1. **All Players Acted**: Every player has either bid or passed
2. **Winner Determined**: One player has the highest valid bid
3. **No Valid Bids**: All players passed (triggers automatic re-deal)

**Completion Logic**:
```rust
fn check_bidding_completion(game_state: &mut GameState) -> Result<(), ValidationError> {
    let all_players_acted = game_state.bidding.bid_history.len() >= 4;
    
    if !all_players_acted {
        return Ok(()); // Bidding continues
    }
    
    // Find highest bidder
    let highest_bidder = game_state.bidding.current_highest_bidder;
    
    if highest_bidder.is_none() {
        // All players passed - automatic re-deal
        auto_redeal_until_valid_hands(game_state)?;
        return Ok(());
    }
    
    // Bidding complete, trump suit already known from winning bid
    game_state.status = GameStatus::Playing;
    game_state.bidding.bidding_complete = true;
    
    // Set first leader (dealer's left neighbor)
    game_state.current_leader = (game_state.dealer_position + 1) % 4;
    
    Ok(())
}

fn auto_redeal_until_valid_hands(game_state: &mut GameState) -> Result<(), ValidationError> {
    const MAX_REDEAL_ATTEMPTS: u32 = 100; // Prevent infinite loops
    
    for _ in 0..MAX_REDEAL_ATTEMPTS {
        // Generate new hands
        deal_new_hands(game_state)?;
        
        // Check if any player has valid bid (5+ trumps in any suit)
        if any_player_has_valid_bid(game_state) {
            // Reset bidding state and start new bidding round
            reset_bidding_state(game_state);
            game_state.status = GameStatus::Bidding;
            return Ok(());
        }
    }
    
    Err(ValidationError::UnableToGenerateValidHands)
}
```

### Phase 3: Trump Information Revelation

When bidding completes, the trump suit is already determined from the winning bid. The system reveals the trump information to all players:

**Trump Revelation Process**:
1. **Winning Bid Identified**: Highest bid with trump suit already specified
2. **Information Broadcast**: All players learn the trump suit for first time
3. **Game State Update**: Trump suit stored in Redis game state
4. **Status Transition**: Game moves directly to "playing" status

**No Additional Validation Required**: Trump suit was already validated during the bid placement.

## Error Handling & Response Codes

### Validation Error Types
```rust
#[derive(Debug, Clone)]
pub enum ValidationError {
    // Game state errors
    GameNotFound,
    GameNotInCorrectStatus,
    PlayerNotInGame,
    
    // Turn-based errors
    NotYourTurn,
    ActionNotAllowed,
    
    // Bidding errors
    BidTooLow,
    BidNotBetter,
    BidExceedsActualTrumps,
    AlreadyPassed,
    
    // Auto-deal errors
    UnableToGenerateValidHands,
    
    // Technical errors
    RedisConnectionFailed,
    SerializationError,
}
```

### HTTP Response Mapping
- **400 Bad Request**: Invalid bid values, malformed requests
- **403 Forbidden**: Not your turn, not authorized to declare trump
- **404 Not Found**: Game doesn't exist
- **409 Conflict**: Game in wrong state, action not allowed
- **500 Internal Server Error**: Redis connection issues, serialization errors

## Security Considerations

### Anti-Cheat Measures
1. **Hand Verification**: All trump count validations check actual cards in Redis
2. **Turn Enforcement**: Strict turn-based validation prevents out-of-order actions
3. **State Consistency**: Every action validates current game state before execution
4. **Immutable History**: Bid history is append-only for audit trail
5. **Player Identity**: JWT validation ensures only authenticated players can act

### Redis Security
1. **Atomic Operations**: Use Redis transactions for state updates
2. **Data Isolation**: Each game has separate Redis keys
3. **Expiration**: Set TTL on game data to prevent stale state
4. **Backup Validation**: Critical validations run against fresh Redis reads

## Frontend Integration

### State Synchronization
1. **WebSocket Updates**: Real-time game state broadcasts
2. **Action Validation**: Frontend pre-validates actions against last known state
3. **Optimistic Updates**: Frontend can show pending actions while waiting for confirmation
4. **Error Handling**: Clear error messages for validation failures
5. **State Reconciliation**: Frontend periodically syncs with backend state

### UI State Management
```typescript
interface GameState {
  status: 'bidding' | 'playing';
  currentBidder: number;
  myPosition: number;
  canBid: boolean;
  canPass: boolean;
  availableBids: Array<{
    length: number;
    suit: string;
    display: string; // e.g., "6 trumps (clubs)"
  }>;
  currentHighestBid: number;
  trumpSuit: string | null; // Only revealed when bidding complete
}
```

### Frontend Bid Calculation
The frontend calculates available bids by:
1. **Calculate Trump Counts**: For each suit, count potential trumps including permanent trumps
2. **Filter Valid Bids**: Only show bids that beat current highest (or equal with clubs)
3. **Display Options**: Show user-friendly descriptions while hiding suit from other players

**Example Available Bids**:
- Player has 5 hearts + 6 permanent = 11 hearts trumps
- Player has 6 clubs + 6 permanent = 12 clubs trumps  
- Current highest bid: 5 trumps

**Available Options**:
- "6 trumps (hearts)" → `{ length: 6, suit: "hearts" }`
- "6 trumps (clubs)" → `{ length: 6, suit: "clubs" }`
- "7 trumps (hearts)" → `{ length: 7, suit: "hearts" }`
- etc.

**Other Players See**: "Player 2 bid 6 trumps" (suit hidden until bidding complete)

This validation framework ensures complete game integrity while providing clear feedback to both honest players and preventing exploitation by bad actors.
